<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Transformation Taxonomy - Tasks People Prompt</title>
  <link rel="stylesheet" href="static/base.css">
  <link rel="stylesheet" href="static/taxtree.css">
  <link rel="stylesheet" href="static/popup.css">
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/bitmaks/cm-web-fonts@latest/fonts.css">
  <link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/dreampulse/computer-modern-web-font/master/fonts.css">

    <!-- Bootstrap CSS desde CDN -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"></link>
  
  <script src="static/include.js" defer></script>
  <script src="static/data_loaders.js"></script>  

  <style>
    .navbar {
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .col-scrollable {
      max-height: 700px;
      overflow: auto;
    }
  </style>
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const closeBtn = document.getElementById('close-popup');
      const popup = document.getElementById('popup');

      closeBtn.addEventListener('click', () => {
          popup.classList.remove('show');
          popup.addEventListener('transitionend', () => {
              if (!popup.classList.contains('show')) {
                  popup.classList.add('hidden');
              }
          }, { once: true });
      });
    });

  </script>
</head>

<body>

  <header>
  <!-- Barra de navegación -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark">

  </nav>

  </header>

  <main class=" container">

  <h1 class="text-center">Transformation Taxonomy</h1>

  <div id="popup" class="popup hidden">
      <div class="popup-content" >
          <span id="close-popup" class="close-btn">&times;</span>

          <p id="details-container">Este es el contenido del div emergente.</p>
      </div>
  </div>

  <div id="tooltip-container" style="position: fixed; pointer-events: none; z-index: 1000;"></div>

  <div class="row split">
    <div class="col col-12 col-md-6" id="categories-container">
      <!-- Se llena con JS -->
    </div>
    <div class="col col-12 col-md-6 col-scrollable" id="task-table">
      <!-- Se llena con JS -->
    </div>



  </div>

</main>


<script>
 // read data/bib_parsed.json
  const bib_data = {};
  async function readBibData(filename) {
    const response = await fetch(filename);
    const data = await response.json();
    Object.assign(bib_data, data);      
  }
  readBibData('data/bib_parsed.json');

  function addTooltipListeners() {
    const valueSpans = document.querySelectorAll('li.value span');
    const tooltipContainer = document.getElementById('tooltip-container');

    valueSpans.forEach(span => {

      span.addEventListener('click', function(event) {
        event.stopPropagation();
        const key = event.target.getAttribute('data-key');

        if (key && bib_data.hasOwnProperty(key)) {
          const bibEntry = bib_data[key];

          // Fill tooltip content
          let content = '<h3>Bibliographic Info</h3> <strong>Tool:</strong> ' + key + '<br>';
          if (bibEntry.title) {
            const title = bibEntry.title.replace(/[{}]/g, '');
            content += `<strong>Title:</strong> ${title}<br>`;
          }
          if (bibEntry.authors) {
            content += `<strong>Authors:</strong> ${bibEntry.authors}<br>`;
          }
          if (bibEntry.href_url) {
            content += `<strong>Link:</strong> <a href="${bibEntry.href_url}" target="_blank">${bibEntry.href_url}</a><br>`;
          }
          document.getElementById('details-container').innerHTML = content;

          // if show not in popup, show it
          const popup = document.getElementById('popup');
          if (popup.classList.contains('hidden')) {
            popup.classList.remove('hidden');
            setTimeout(() => popup.classList.add('show'), 10); // permite animación

          }
          
        }
      });

      span.addEventListener('mouseover', function(event) {
        const key = event.target.getAttribute('data-key');

        if (key && bib_data.hasOwnProperty(key)) {
          const bibEntry = bib_data[key];
          
          // Clear previous tooltips
          tooltipContainer.innerHTML = '';
          
          // Create tooltip element
          const tooltip = document.createElement('div');
          //tooltip.className = 'tooltip';
          tooltip.style.position = 'fixed';
          tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
          tooltip.style.color = 'white';
          tooltip.style.padding = '8px';
          tooltip.style.borderRadius = '4px';
          tooltip.style.maxWidth = '600px';
          tooltip.style.fontSize = '0.9em';
          tooltip.style.whiteSpace = 'normal';
          tooltip.style.wordWrap = 'break-word';
          

          // Fill tooltip content
          let content = '';
          if (bibEntry.title) {
            const title = bibEntry.title.replace(/[{}]/g, '');
            content += `<strong>Title:</strong> ${title}<br>`;
          }
          if (bibEntry.authors) {
            content += `<strong>Authors:</strong> ${bibEntry.authors}<br>`;
          }

          // Position the tooltip
          tooltip.style.left = (event.clientX + 10) + 'px';
          tooltip.style.top = (event.clientY + 10) + 'px';
          tooltip.innerHTML = content;

          //document.getElementById('details-container').innerHTML = content;


          tooltipContainer.appendChild(tooltip);
        }
      });

      
      span.addEventListener('mouseout', function() {
        tooltipContainer.innerHTML = '';
      });
      


    });
  }

</script>


<script>


function cTree(data, category="") {
  html = '';
  if (typeof data === 'object') {
    html += '<ul class="tree">'
    for (const key in data) {
      if (category === "" && key in category_colors) {
        category = key;
      }

      html += `<li><details><summary class="cat-${category}">${key}</summary>`;

      value = data[key];
      if (Array.isArray(value)) {
        html += '<ul class="tree cat-' + category + '">';
        value.forEach(item => {
          if (typeof item === 'object') {
            html += '<li class="sub-tree">' + cTree(item, category) + '</li>';
          } else {
            html += `<li class="value" data-cat="${category}">${item}</li>`;
          }
          
        });

        html += '</ul>';
      }

      html += '</details></li>';
      category = "";
    }
    html +=  '</ul>';
  }

  return html;
}

</script>



  <script>
    var category_colors = {
      "Generative": "#c1e1f3",
      "Evaluative": "#e6ecbc",
      "Extractive": "#f3d8c1",
      "Abstractive": "#efc6d7",
      "Executive": "#ceb7d4",
      "Consultative": "#acc0b8"
    };

    async function renderTree(file_url = 'tree.json', container_id = 'treeview') {
      const response = await fetch(file_url);
      const treeData = await response.json();

      const container = document.getElementById(container_id);

      function createTree(data, category = "") {
        if (data == null) return '';

        const classAttr = category ? ' class="tree cat-' + category + '"' : ' class="tree"';
        let html = '<ul' + classAttr + '>';

        // If data is an array, render each item (string or nested object)
        if (Array.isArray(data)) {
          data.forEach(item => {
            if (typeof item === 'string') {
              html += `<li>${item}</li>`;
            } else if (typeof item === 'object') {
              html += createTree(item, category);
            }
          });
        } else if (typeof data === 'object') {
          for (const key in data) {
            if (!Object.prototype.hasOwnProperty.call(data, key)) continue;
            const value = data[key];

            // Determine category for coloring: top-level keys that match category_colors become the category
            let currentCategory = category;
            if (!category && key in category_colors) {
              currentCategory = key;
            }

            if (Array.isArray(value)) {
              const summaryClass = currentCategory ? ` class="cat-${currentCategory}"` : '';
              html += `<li><details><summary${summaryClass}>${key}</summary>`;
              html += '<ul>';
              value.forEach(child => {
                if (typeof child === 'string') {
                  html += `<li>${child}</li>`;
                } else if (typeof child === 'object') {
                  treeHtml= createTree(child, currentCategory);
                  html += treeHtml;
                }
              });
              html += '</ul></details></li>';
            } else if (typeof value === 'object') {
              html += `<li>${key}` + createTree(value, currentCategory) + '</li>';
            } else {
              html += `<li>${value}</li>`;
            }
          }
        } else {
          html += `<li>${data}</li>`;
        }

        html += '</ul>';
        return html;
      }


      container.innerHTML = cTree(treeData);

      addEventListeners();

    }

    renderTree('data/taxonomy.json', 'categories-container');
    //renderHTMLTaskTable('data/tasks_from_html.json', 'task-table');


    const tasks = {};
    async function readTaskData(filename) {
      const response = await fetch(filename);
      const taskData = await response.json();
      tasks['data'] = taskData;      
    }

    readTaskData('data/tasks.json');

  </script>


<script>

  // load data/categories_from_tex.json as a object
  const tex_categories = {};
  async function readTexCategories(filename) {
    const response = await fetch(filename);
    const categoryData = await response.json();
    Object.assign(tex_categories, categoryData);      
  }
  readTexCategories('data/categories_from_tex.json');


  function addEventListeners() {
    const listItems = document.querySelectorAll('li.value');

    listItems.forEach(item => {
      item.addEventListener('click', function() {
          const taskName = event.target.textContent;
          const catName = event.target.getAttribute('data-cat');

          //remove spaces from taskName
          const texKey = catName + '/' + taskName.replace(/\s+/g, '');


          if (event.target.classList.contains('selected-task')) {
            // unselect
            event.target.style.backgroundColor = '';
            event.target.classList.remove('selected-task');

            const tableValues = document.querySelectorAll('.table-value');
            tableValues.forEach(tv => {
              tv.style.backgroundColor = '';
              tv.style.display = 'block';
            });

            return;
          } else {
            // clean previous selection
            const previousSelected = document.querySelectorAll('.selected-task');
            previousSelected.forEach(ps => {
              ps.style.backgroundColor = '';
              ps.classList.remove('selected-task');
            });

            event.target.style.backgroundColor = 'yellow';
            event.target.classList.add('selected-task');

            
          }
          //alert(texKey);
          
          // insert dictionary inside task-table
          const taskTable = document.getElementById('task-table');

          const texData = tex_categories[texKey];
          let html = '<h2>' + texKey + '</h2>';
          
          // just print texData as text inside taskTable
          //html += '<pre>' + JSON.stringify(texData, null, 2) + '</pre>';
          html += texDataToHtml(texData);
          taskTable.innerHTML = html;

          addTooltipListeners();

        });
      });

  };

  function texDataToHtml(data) {
    //data is a dictionary
    let html = '<ul class="tree">';
    for (const key in data) {
      if (!Object.prototype.hasOwnProperty.call(data, key)) continue;
      const value = data[key];

      html += `<li><details open><summary>${key}</summary>`;

      if (Array.isArray(value)) {
        html += '<ul>';
        value.forEach(item => {
          if (Array.isArray(item)) {
            if (item.length >= 3) {
              html += `<li class="value ${item[0]}"><span data-key="${item[1]}" >` + item[1]  + `<sub>${item[2]}</sub></span></li>`;
            } else if (item.length === 2) {
              html += `<li class="value ${item[0]}"><span data-key="${item[1]}">` + item[1] + `</span></li>`;
            } else {
              // join item and display in single li
              html += `<li class="value ">!!` + item.join(' ') + `</li>`;
            }

          } 
          else if (typeof item === 'object') {
            html += '<li class="sub-tree">' + texDataToHtml(item) + '</li>';
          } else {
            html += `<li class="value">${item}</li>`;
          }
          
        });

        html += '</ul>';
      } else if (typeof value === 'object') {
        html += texDataToHtml(value);
      } else {
        html += `<li>${value}</li>`;
      }

      html += '</details></li>';

    }
    html +=  '</ul>';
    return html;

  }
</script>


</body>

</html>